# 32. 整数中1出现的次数（从1到n整数中1出现的次数）
## 题目
求出1 ~ 13的整数中1出现的次数,并算出100 ~ 1300的整数中1出现的次数？为此他特别数了一下1 ~ 13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。

## 思路
这道题是分析了书本上的方法很多遍之后，在脑海中形成了大致的思路，然后自我改造而成，窃以为，代码要比书本上的代码好理解一些，主要还是思路的形成。

我们来举个例子，比如 n = 12345，那么我们可以把递归拆分为类似下面的结构
```
                   1 ~ 12345
                    /     \
                   /       \
                  /         \
             1 ~ 2345  |  2346 ~ 12345
              /     \
             /       \
            /         \  
         1 ~ 345  |  346 ~ 2345
         /     \
        /       \
      1 ~ 45 |  46 ~ 345
      /     \
    1 ~ 5 | 6 ~ 45
```
那么我们其实只要把右子树的问题解决了就可以了。

比如2346 ~ 12345，恰好是10000个数，后四位完全覆盖了0000 ~ 9999的所有组合。令后四位任意一位为1，其余位均可以取0至9中的任意一个，因而后四位中1的个数有```4 * 10 ^ 3```个。此处很多人可能会疑惑，如果后四位中第2位（从左向右）取1，那么第一位应该不能取0才对啊，这正是划分为这类子问题的妙处，如果是四位数，第二位取1的话第一位自然不能为0，但是我们有五位数存在，五位数的首位保障了后四位可以任意取，又让人疑惑的是，后四位中第一位取1，不是会比2346还要小吗？还是因为我们有五位数存在，11XXX同样是在2346 ~ 12345范围内的。那么考虑完后四位之后，我们再考虑首位，首位1的个数共有 2345 + 1 = 2346个，也就是10000至12345折2346个。

再比如346 ~ 2345，后三位任意一位取1，其余位可以是0到9中的任意一个，因而后三位中1的个数总共是```3 * 10 ^ 2```,又考虑到首位是2，也就是说346 ~ 2345总共是2000个数，346 ~ 1345可以使得后三位有300个1,2346 ~ 2345也可以使得后三位有300个1，因为后三位一共有 2 * 300 个1。再考虑首位，因为首位比1大，所以首位为1的是1000至1999，总共1000个1.那么一共就是``` 2 * (3 * 10 ^ 2) + 10 ^ 3```

举了这两个例子就可以发现其中的规律了：
```
firstDig = n / (10 ^ (len - 1));
ans += firstDig * (len - 1) * 10 ^ (len - 2);
and += firstDig == 1 ? n % (10 ^ (len - 1)) + 1 : 10 ^ (len - 1);
```
代码如下所示：
```C++
class Solution {
public:
    int pow10(int i){
        int ans = 1;
        for(int k = 0; k < i; ++k){
            ans *= 10;
        }
        return ans;
    }
    int NumberOf1Between1AndN_Solution(int n)
    {
        int temp = n;
        int len = 0;
        int ans = 0;
        if (n < 1)
            return 0;
        while(temp){
            len++;
            temp /= 10;
        }
        temp = n;
        while(temp){
            int pow10Temp = pow10(len - 1);
            int a = temp / pow10Temp;
            ans += a * (len - 1) * (pow10Temp / 10);
            if(a == 1)
                ans += temp % pow10Temp + 1;
            else
                ans += pow10Temp;
            temp %= pow10Temp;
            len--;
        }
        return ans;
    }
};
```
